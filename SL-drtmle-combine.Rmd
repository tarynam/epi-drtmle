---
title: "SL drtmle S. mansoni Infection and Tuberculosis"
author: "Taryn McLaughlin"
date: "02/19/2020"
output: html_document
---
##Set Up
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=FALSE, message=FALSE)
```

```{r Package Requirements, message=FALSE}
##package requirements
pkgs <- c("drtmle","earth","SuperLearner","nloptr", "quadprog","plotmo","plotrix",
          "TeachingDemos","gam","caret","randomForest","arm","RCurl","MASS",
          "tmle","drtmle", "knitr", "ranger", "xgboost", "ggplot2","gbm", "dplyr", "tidyr", "data.table")

# see what packages are currently installed
installed_pacakges <- row.names(installed.packages()) # loop over the needed packages
for(p in pkgs){
    # check if package is installed
    already_installed <- p %in% installed_pacakges
    # if not already installed, install it
    if(!already_installed){ install.packages(p)
    }
    # and load package
    library(p, character.only = TRUE) }

remove(pkgs, installed_pacakges, p, already_installed)
```

###QC Data
```{r Load Data}
dat<-read.csv("/Applications/Old Computer/Epi Project/Data_clean/Kenya_analysis.csv")
dat<-dplyr::select(dat, -X, -egg, -ControlQFT.ind, -ControlQFT)
dat$Number<-dat$Number-dat$SM
for(i in 1:length(dat)){
    n<-length(which(is.na(dat[[i]])))
    print(n)
    }
```

###Wrappers
```{r Wrappers}
#SL.mean
#SL.step.forward
#SL.step.interaction
#SL.rpartPrune

SL.xgboost2<-function(..., maxdepth = 2){
    SL.xgboost(..., max_depth = maxdepth)
}
SL.xgboost4<-function(..., maxdepth = 4){
    SL.xgboost(..., max_depth = maxdepth)
}
SL.xgboost6<-function(..., maxdepth = 6){
    SL.xgboost(..., max_depth = maxdepth)
}

SL.ranger2<-function(..., mtry = 2){
    SL.ranger(..., mtry = mtry)
}
SL.ranger4<-function(..., mtry = 4){
    SL.ranger(..., mtry = mtry)
}
SL.ranger6<-function(..., mtry = 6){
    SL.ranger(..., mtry = mtry)
}

SL.earth.cv <- function(..., nfold = 5){
        SL.earth(..., nfold = nfold)
}

SL.myglm.eachworm <- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "SM + ascaris + tricuris + hookworm"
    other_variables <- " + age + sex + hiv + viral.load + vl.ind + HB + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}

SL.myglm.eachworm.g <- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "ascaris + tricuris + hookworm"
    other_variables <- " + age + sex + hiv + viral.load + vl.ind + HB + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}

SL.myglm.totalworm <- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "SM + Number"
    other_variables <- " + age + sex + hiv + viral.load + vl.ind  + HB + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}


SL.myglm.totalworm.g <- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "Number"
    other_variables <- " + age + sex + hiv + viral.load + vl.ind + HB + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}

#gam is a glm but flexibly (non-parametrically) models continuous variables
#instead use s(age) in a glm that you define like the other glms --> s stands for splines
#basically doesn't force things to be linear
SL.myspline.eachworm<- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "SM + ascaris + tricuris + hookworm"
    other_variables <- " + s(age) + sex + hiv + s(viral.load) + vl.ind + s(HB) + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
} 

SL.myspline.eachworm.g<- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "ascaris + tricuris + hookworm"
    other_variables <- " + s(age) + sex + hiv + s(viral.load) + vl.ind + s(HB) + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
} 


SL.myspline.totalworm<- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "SM + s(Number)"
    other_variables <- " + s(age) + sex + hiv + s(viral.load) + vl.ind + s(HB) + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}

SL.myspline.totalworm.g<- function(Y, X, newX, family, ...){
    rhs_glm_formula <- "s(Number)"
    other_variables <- " + s(age) + sex + hiv + s(viral.load) + vl.ind + s(HB) + HB.ind + malariaNEG + malariaPOS + pregnantNEG + pregnantPOS + siteJOOTRH + siteKOMBEWA"
    # the rest of the code takes care of things SuperLearner needs
    glm_formula <- paste0("Y ~ ", rhs_glm_formula, other_variables)
    fit.glm <- glm(glm_formula, data = data.frame(Y , X), family = family)
    pred <- predict(fit.glm, newdata = newX, type = "response")
    fit <- list(object = fit.glm)
    class(fit) <- "SL.glm"
    out <- list(pred = pred, fit = fit)
    return(out)
}

#In case modeling on the total data gives us entirely different results than if we modeled separately on HIV

SL.glmnet2way<-function (Y, X, newX, family, obsWeights, id, alpha = 1, nfolds = 10, 
                         nlambda = 100, useMin = TRUE, loss = "deviance", ...) {
    SuperLearner:::.SL.require("glmnet") #keep this one
    if (!is.matrix(X)) {
        X <- model.matrix(~-1 + .^2, X) #updated
        newX <- model.matrix(~-1 + .^2, newX) #updated
    }
    fitCV <- glmnet::cv.glmnet(x = X, y = Y, weights = obsWeights, 
                               lambda = NULL, type.measure = loss, nfolds = nfolds, 
                               family = family$family, alpha = alpha, nlambda = nlambda, 
                               ...)
    pred <- predict(fitCV, newx = newX, type = "response", s = ifelse(useMin, 
                                                                      "lambda.min", "lambda.1se"))
    fit <- list(object = fitCV, useMin = useMin)
    class(fit) <- "SL.glmnet2way" #changed this to match the name
    out <- list(pred = pred, fit = fit)
    return(out)
}
#How does this know to pull from the new glmnet and not the old one???
predict.SL.glmnet2way<-function (object, newdata, remove_extra_cols = T, add_missing_cols = T, ...) 
{
    SuperLearner:::.SL.require("glmnet") #keep this one
    if (!is.matrix(newdata)) {
        newdata <- model.matrix(~-1 + .^2, newdata) #updated
    }
    original_cols = rownames(object$object$glmnet.fit$beta) #This is where I wasn't sure. 
    if (remove_extra_cols) {
        extra_cols = setdiff(colnames(newdata), original_cols)
        if (length(extra_cols) > 0) {
            warning(paste("Removing extra columns in prediction data:", 
                          paste(extra_cols, collapse = ", ")))
            newdata = newdata[, !colnames(newdata) %in% extra_cols, 
                              drop = F]
        }
    }
    if (add_missing_cols) {
        missing_cols = setdiff(original_cols, colnames(newdata))
        if (length(missing_cols) > 0) {
            warning(paste("Adding missing columns in prediction data:", 
                          paste(missing_cols, collapse = ", ")))
            new_cols = matrix(0, nrow = nrow(newdata), ncol = length(missing_cols))
            colnames(new_cols) = missing_cols
            newdata = cbind(newdata, new_cols)
            newdata = newdata[, original_cols]
        }
    }
    pred <- predict(object$object, newx = newdata, type = "response", 
                    s = ifelse(object$useMin, "lambda.min", "lambda.1se"))
    return(pred)
}


SL.stratify.glm <- function(Y, X, newX, stratify_variable = "hiv", family, ...){
        # subset to folks with stratify variable == 1
        X_strat1 <- X[X[,stratify_variable] == 1, , drop = FALSE]
        # drop stratify variable
        X_strat1 <- X_strat1[ , -which(colnames(X_strat1) == stratify_variable)]
        # same thing for held-out data
        newX_strat1 <- newX[newX[,stratify_variable] == 1, , drop = FALSE]
        newX_strat1 <- newX_strat1[ , -which(colnames(newX_strat1) == stratify_variable)]
        # same thing for outcome
        Y_strat1 <- Y[X[,stratify_variable] == 1]
        glm_strat1 <- glm(Y_strat1 ~ . , data = X_strat1, family = family)
        pred_strat1 <- predict(glm_strat1, newdata = newX_strat1, type = "response")
        
        # now play the same game in folks with stratify variable == 0
        # subset to folks with stratify variable == 0
        X_strat0 <- X[X[,stratify_variable] == 0, , drop = FALSE]
        # drop stratify variable
        X_strat0 <- X_strat0[ , -which(colnames(X_strat0) == stratify_variable)]
        # same thing for held-out data
        newX_strat0 <- newX[newX[,stratify_variable] == 0, , drop = FALSE]
        newX_strat0 <- newX_strat0[ , -which(colnames(newX_strat0) == stratify_variable)]
        # same thing for outcome
        Y_strat0 <- Y[X[,stratify_variable] == 0]
        glm_strat0 <- glm(Y_strat0 ~ . , data = X_strat0, family = family)
        pred_strat0 <- predict(glm_strat0, newdata = newX_strat0, type = "response")
 
        # now wrap up in a way that SuperLearner likes
        fit <- list(object_strat0 = glm_strat0, object_strat1 = glm_strat1, 
                    stratify_variable = stratify_variable)
        class(fit) <- "SL.stratify.glm"
        pred <- rep(NA, nrow(newX))
        pred[newX[,stratify_variable] == 1] <- pred_strat1
        pred[newX[,stratify_variable] == 0] <- pred_strat0
        out <- list(pred = pred, fit = fit)
        return(out)
}
predict.SL.stratify.glm <- function(object, newdata, ...){
        # subset newdata based on stratify variable
        newdata_strat1 <- newdata[newdata[,object$stratify_variable] == 1, , drop = FALSE]
        newdata_strat0 <- newdata[newdata[,object$stratify_variable] == 0, , drop = FALSE]
        pred_strat1 <- predict(object$object_strat1, newdata = newdata_strat1, type = "response")
        pred_strat0 <- predict(object$object_strat0, newdata = newdata_strat0, type = "response")
        pred <- rep(NA, nrow(newdata))
        pred[newdata[,stratify_variable] == 1] <- pred_strat1
        pred[newdata[,stratify_variable] == 0] <- pred_strat0 
        return(pred)
}
```

##Super Learner Regressions
I've done this in the past and stored them so these don't evaluate but you can see the code just in case. I also generate the cross-validated SL here as well.  
###Propensity Score - S. mansoni infection
```{r propensity superlearner, eval=FALSE}
SL_g <- SuperLearner(
    # our outcome is now the S. mansoni variable
    Y = dat$SM, 
    # our predictors are all variables except for LTBI and S. mansoni
    X = dplyr::select(dat, -SM, -ltbi, -tb, -hc),
    # outcome is binary, so let's use family = binomial()
    family = binomial(),
    # and convex combination nnloglikelihood method
    method= "method.CC_nloglik",
    # simple library for now
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm.g", "SL.myglm.totalworm.g", 
        "SL.myspline.eachworm.g", 
        "SL.glmnet2way", "SL.stratify.glm"),
    cvControl = list(V = 10), verbose = TRUE
)
save(SL_g, file = "/Users/tarynam/Desktop/epi-drtmle/SL_g.RData")

cv_g<-CV.SuperLearner(
        # our outcome is now the S. mansoni variable
    Y = dat$SM, 
    # our predictors are all variables except for LTBI and S. mansoni
    X = dplyr::select(dat, -SM, -ltbi, -tb, -hc),
    # outcome is binary, so let's use family = binomial()
    family = binomial(),
    # and convex combination nnloglikelihood method
    method= "method.CC_nloglik",
    # simple library for now
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm.g", "SL.myglm.totalworm.g", 
        "SL.myspline.eachworm.g", 
        "SL.glmnet2way", "SL.stratify.glm"),
    cvControl = list(V = 10), verbose = TRUE
)
save(cv_g, file = "/Users/tarynam/Desktop/epi-drtmle/cv_g.RData")

```

###Latent TB Infection (LTBI) Outcome Regression
```{r ltbi superlearner, eval=FALSE}
SL_ltbi <- SuperLearner(
    # Y is the outcome variable
    Y = dat$ltbi,
    # X is a dataframe of predictor variables, in this casce
    # everything in dat except for TB outcomes
    X = dplyr::select(dat,-ltbi, -hc, -tb), 
    newX = NULL,
    # family set to binomial() for 0/1 outcome
    family = binomial(), 
    # SL.library will be filled more completely later
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm", "SL.myglm.totalworm", 
        "SL.myspline.eachworm", "SL.myspline.totalworm", 
        "SL.glmnet2way"),
    # method specifies how the ensembling is done
    # convex combination negative log-likelihood
    method = "method.CC_nloglik",
    # id specifies a unique subject identifier. data only has one row 
    # per subject, so OK to leave as NULL (default)
    id = NULL, 
    # verbose controls the printing of messages of SuperLearner's progress.
    verbose = FALSE, 
    # control contains options related to logistic ensemble (trimLogit) 
    # and whether to #save the fit library to look at individual 
    # algorithms later. We will leave as default
    control = list(saveFitLibrary = TRUE, trimLogit = 0.001),
    # cvControl specifies parameters related to cross validation. Of note
    # the default is for V=10-fold cross validation. See ?SuperLearner
    # for more details
    cvControl = list(V = 10L, stratifyCV = FALSE, shuffle = TRUE, 
                     validRows = NULL)
)
save(SL_ltbi, file = "/Users/tarynam/Desktop/epi-drtmle/SL_ltbi.RData")

cv_ltbi <- CV.SuperLearner(
    # Y is the outcome variable
    Y = dat$ltbi,
    # X is a dataframe of predictor variables, in this casce
    # everything in dat except for TB outcomes
    X = dplyr::select(dat,-ltbi, -hc, -tb),
    # family set to binomial() for 0/1 outcome
    family = binomial(), 
    # SL.library will be filled more completely later
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm", "SL.myglm.totalworm", 
        "SL.myspline.eachworm", "SL.myspline.totalworm", 
        "SL.glmnet2way"),
    # method specifies how the ensembling is done
    # convex combination negative log-likelihood
    method = "method.CC_nloglik",
    # id specifies a unique subject identifier. data only has one row 
    # per subject, so OK to leave as NULL (default)
    id = NULL, 
    # verbose controls the printing of messages of SuperLearner's progress.
    verbose = FALSE, 
    # control contains options related to logistic ensemble (trimLogit) 
    # and whether to #save the fit library to look at individual 
    # algorithms later. We will leave as default
    control = list(saveFitLibrary = TRUE, trimLogit = 0.001),
    # cvControl specifies parameters related to cross validation. Of note
    # the default is for V=10-fold cross validation. See ?SuperLearner
    # for more details
    cvControl = list(V = 10L, stratifyCV = FALSE, shuffle = TRUE, 
                     validRows = NULL)
)
save(cv_ltbi, file = "/Users/tarynam/Desktop/epi-drtmle/cv_ltbi.RData")
```

###Active TB Infection (TB) Outcome Regression
```{r tb superlearner, eval=FALSE}
SL_tb <- SuperLearner(
    # Y is the outcome variable
    Y = dat$tb,
    # X is a dataframe of predictor variables, in this casce
    # everything in dat except for TB outcomes
    X = dplyr::select(dat,-ltbi, -hc, -tb), 
    newX = NULL,
    # family set to binomial() for 0/1 outcome
    family = binomial(), 
    # SL.library will be filled more completely later
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm", "SL.myglm.totalworm", 
        "SL.myspline.eachworm", "SL.myspline.totalworm", 
        "SL.glmnet2way"),
    # method specifies how the ensembling is done
    # convex combination negative log-likelihood
    method = "method.CC_nloglik",
    # id specifies a unique subject identifier. data only has one row 
    # per subject, so OK to leave as NULL (default)
    id = NULL, 
    # verbose controls the printing of messages of SuperLearner's progress.
    verbose = FALSE, 
    # control contains options related to logistic ensemble (trimLogit) 
    # and whether to #save the fit library to look at individual 
    # algorithms later. We will leave as default
    control = list(saveFitLibrary = TRUE, trimLogit = 0.001),
    # cvControl specifies parameters related to cross validation. Of note
    # the default is for V=10-fold cross validation. See ?SuperLearner
    # for more details
    cvControl = list(V = 10L, stratifyCV = FALSE, shuffle = TRUE, 
                     validRows = NULL)
)
save(SL_tb, file = "/Users/tarynam/Desktop/epi-drtmle/SL.RData")

cv_tb <- CV.SuperLearner(
    # Y is the outcome variable
    Y = dat$tb,
    # X is a dataframe of predictor variables, in this casce
    # everything in dat except for TB outcomes
    X = dplyr::select(dat,-ltbi, -hc, -tb),
    # family set to binomial() for 0/1 outcome
    family = binomial(), 
    # SL.library will be filled more completely later
    SL.library = c("SL.mean", "SL.step.forward", "SL.rpartPrune",
        "SL.xgboost2", 'SL.xgboost4', "SL.xgboost6", 
        "SL.ranger2", "SL.ranger4", "SL.ranger6", 
        "SL.earth.cv", "SL.step.interaction",
        "SL.myglm.eachworm", "SL.myglm.totalworm", 
        "SL.myspline.eachworm", "SL.myspline.totalworm", 
        "SL.glmnet2way"),
    # method specifies how the ensembling is done
    # convex combination negative log-likelihood
    method = "method.CC_nloglik",
    # id specifies a unique subject identifier. data only has one row 
    # per subject, so OK to leave as NULL (default)
    id = NULL, 
    # verbose controls the printing of messages of SuperLearner's progress.
    verbose = FALSE, 
    # control contains options related to logistic ensemble (trimLogit) 
    # and whether to #save the fit library to look at individual 
    # algorithms later. We will leave as default
    control = list(saveFitLibrary = TRUE, trimLogit = 0.001),
    # cvControl specifies parameters related to cross validation. Of note
    # the default is for V=10-fold cross validation. See ?SuperLearner
    # for more details
    cvControl = list(V = 10L, stratifyCV = FALSE, shuffle = TRUE, 
                     validRows = NULL)
)
save(cv_tb, file = "/Users/tarynam/Desktop/epi-drtmle/cv.RData")
```

```{r if needed load SL from file}
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/SL_g.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/SL_ltbi.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/SL_tb.RData")

#load("/Users/tarynam/Desktop/epi-drtmle/original analysis/cv_g.RData")
#load("/Users/tarynam/Desktop/epi-drtmle/original analysis/cv_ltbi.RData")
#load("/Users/tarynam/Desktop/epi-drtmle/original analysis/cv.RData")
```

##drtmle
###Creating the propensity score lists
```{r propensity, eval=FALSE}
set.seed(1234)
###Propensity scores aka gn in drtmle

###HIV NEGATIVE

    # since we want to run drtmle on HIV- and HIV+ separately we need a way to
    # only include propensity scores for each group
    include<- dat$hiv==0
    
    # get propensity scores where P(A = 1 | W) for all observations
    # by extracting SL.pred values from the superlearner object
    gn_1 <- as.numeric(SL_g$SL.pred)[include]
    
    # generate gn list (the 10 part indicates the order aka A=1 then A=0)
    gn_neg <- list(
        # first entry is P(A = 1 | W)
        gn_1,
        # second entry is P(A = 0 | W) = 1 - P(A = 1 | W)
        (1 - gn_1)
    )
    
####HIV POSITIVE

    # since we want to run drtmle on HIV- and HIV+ separately we need a way to
    # only include propensity scores for each group
    include<- dat$hiv==1
    
    # get propensity scores where P(A = 1 | W) for all observations
    # by extracting SL.pred values from the superlearner object
    gn_1 <- as.numeric(SL_g$SL.pred)[include]

    # generate gn list (the 10 part indicates the order aka A=1 then A=0)
    gn_pos <- list(
        # first entry is P(A = 1 | W)
        gn_1,
        # second entry is P(A = 0 | W) = 1 - P(A = 1 | W)
        (1 - gn_1)
    )
    
####Total    
    gn_1 <- as.numeric(SL_g$SL.pred)
    
    # generate gn list (the 10 part indicates the order aka A=1 then A=0)
    gn <- list(
        # first entry is P(A = 1 | W)
        gn_1,
        # second entry is P(A = 0 | W) = 1 - P(A = 1 | W)
        (1 - gn_1)
    )
    
```

###LTBI
```{r LTBI drtmle, eval=FALSE}
set.seed(1234)
###HIV Negative Outcome Regressions aka Qn in drtmle 
    
    # Again we only want the outcome regressions for the HIV- subset
    data<-dat[dat$hiv==0,]
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat0$SM <- 0
    
    # for each SM=0 and SM=1 get OR values for each row of the new data frame
    # using the predict function in the OR model built by super learner (SL_Q)
    Q1n <- predict(SL_ltbi, newdata=dat1)$pred
    Q0n <- predict(SL_ltbi, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn_neg <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )

fit_LTBI_HIVneg <- drtmle(Y=data$ltbi, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn_neg, gn = gn_neg, 
                     SL_gr = c("SL.earth", "SL.glm", "SL.mean"), SL_Qr = c("SL.earth", "SL.glm", "SL.mean"))

save(fit_LTBI_HIVneg, file="/Users/tarynam/Desktop/epi-drtmle/fit_LTBI_HIVneg.RData")

###HIV Positive Outcome Regressions aka Qn in drtmle
    
    # Again we only want the outcome regressions for the HIV- subset
    data<-dat[dat$hiv==1,]
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data, -ltbi, -hc, -tb)
    dat0$SM <- 0   
    
    # for each SM=0 and SM=1 get OR values for each row of the new data frame
    # using the predict function in the OR model built by super learner (SL_Q)
    Q1n <- predict(SL_ltbi, newdata=dat1)$pred
    Q0n <- predict(SL_ltbi, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn_pos <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )

fit_LTBI_HIVpos <- drtmle(Y=data$ltbi, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn_pos, gn = gn_pos, 
                     SL_gr = c("SL.earth", "SL.glm"), SL_Qr = c("SL.earth", "SL.glm")
)
save(fit_LTBI_HIVpos, file="/Users/tarynam/Desktop/epi-drtmle/fit_LTBI_HIVpos.RData")

    data<-dat
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data, -ltbi, -hc, -tb)
    dat0$SM <- 0  

    Q1n <- predict(SL_ltbi, newdata=dat1)$pred
    Q0n <- predict(SL_ltbi, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )
    


fit_LTBI <- drtmle(Y=data$ltbi, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn, gn = gn, 
                     SL_gr = c("SL.earth", "SL.glm"), SL_Qr = c("SL.earth", "SL.glm")
)

save(fit_LTBI, file="/Users/tarynam/Desktop/epi-drtmle/fit_LTBI.RData")
```

###TB
```{r TB drtmle, eval=FALSE}
set.seed(1234)
###HIV Negative Outcome Regressions aka Qn in drtmle 
    
    # Again we only want the outcome regressions for the HIV- subset
    data<-dat[dat$hiv==0,]
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat0$SM <- 0
    
    # for each SM=0 and SM=1 get OR values for each row of the new data frame
    # using the predict function in the OR model built by super learner (SL_Q)
    Q1n <- predict(SL_tb, newdata=dat1)$pred
    Q0n <- predict(SL_tb, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn_neg <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )

fit_TB_HIVneg <- drtmle(Y=data$tb, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn_neg, gn = gn_neg, 
                     SL_gr = c("SL.earth", "SL.glm", "SL.mean"), SL_Qr = c("SL.earth", "SL.glm", "SL.mean"))
save(fit_TB_HIVneg, file="/Users/tarynam/Desktop/epi-drtmle/fit_TB_HIVneg.RData")

###HIV Positive Outcome Regressions aka Qn in drtmle
    
    # Again we only want the outcome regressions for the HIV- subset
    data<-dat[dat$hiv==1,]
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data, -ltbi, -hc, -tb)
    dat0$SM <- 0   
    
    # for each SM=0 and SM=1 get OR values for each row of the new data frame
    # using the predict function in the OR model built by super learner (SL_Q)
    Q1n <- predict(SL_tb, newdata=dat1)$pred
    Q0n <- predict(SL_tb, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn_pos <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )

fit_TB_HIVpos <- drtmle(Y=data$tb, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn_pos, gn = gn_pos, 
                     SL_gr = c("SL.earth", "SL.glm"), SL_Qr = c("SL.earth", "SL.glm")
)
save(fit_TB_HIVpos, file="/Users/tarynam/Desktop/epi-drtmle/fit_TB_HIVpos.RData")


###Total 
    data<-dat
    # set up a data frame where everyone has SM=1 or SM=0
    dat1 <- dplyr::select(data,-ltbi, -hc, -tb)
    dat1$SM <- 1
    dat0 <- dplyr::select(data, -ltbi, -hc, -tb)
    dat0$SM <- 0  

    Q1n <- predict(SL_tb, newdata=dat1)$pred
    Q0n <- predict(SL_tb, newdata=dat0)$pred
    
    # generate Qn list (the 10 part indicates the order aka A=1 then A=0)
    Qn <- list(
      # first entry is predicted values setting A = 1
      Q1n,
      # second entry is predicted values setting A = 0
      Q0n
    )
    
fit_TB <- drtmle(Y=data$tb, A=data$SM, 
                     W=dplyr::select(data, -SM, -hc, -ltbi, -tb),
                     a_0 = c(1,0), family = binomial(),
                     Qn = Qn, gn = gn, 
                     SL_gr = c("SL.earth", "SL.glm"), SL_Qr = c("SL.earth", "SL.glm")
)
save(fit_TB, file="/Users/tarynam/Desktop/epi-drtmle/fit.RData")
```

```{r UPDATE THIS}
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_LTBI_HIVneg.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_LTBI_HIVpos.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_LTBI.RData")

IC_LTBI_HIVneg<-fit_LTBI_HIVneg$ic_drtmle$ic
IC_LTBI_HIVpos<-fit_LTBI_HIVpos$ic_drtmle$ic
IC_LTBI<-fit_LTBI$ic_drtmle$ic

load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_TB_HIVneg.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_TB_HIVpos.RData")
load("/Users/tarynam/Desktop/epi-drtmle/941/191031_original analysis/fit_TB.RData")

IC_TB_HIVneg<-fit_TB_HIVneg$ic_drtmle$ic
IC_TB_HIVpos<-fit_TB_HIVpos$ic_drtmle$ic
IC_TB<-fit_TB$ic_drtmle$ic
```

##Statistical Analysis
###Total
```{r}
N<-dim(IC_LTBI)[1]

## Estimates
lfit<-round(ci(fit_LTBI)[[1]], 3)
tfit<-round(ci(fit_TB)[[1]], 3)
HC<-c(1-(lfit[1,1]+tfit[1,1]),
      1-(lfit[2,1]+tfit[2,1]))
est<-100*c(HC, lfit[,1], tfit[,1])

## Confidence Intervals SM
#HC SM+
D<-cov(cbind(IC_LTBI[,1], IC_TB[,1]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.pos.up<-round(HC[1]+1.96*sqrt(var), 3)
hc.pos.low<-round(HC[1]-1.96*sqrt(var), 3)

#HC SM-
D<-cov(cbind(IC_LTBI[,2], IC_TB[,2]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.neg.up<-round(HC[2]+1.96*sqrt(var), 3)
hc.neg.low<-round(HC[2]-1.96*sqrt(var), 3)
cil<-100*c(hc.pos.low, hc.neg.low, lfit[,2], tfit[,2])
ciu<-100*c(hc.pos.up, hc.neg.up, lfit[,3], tfit[,3])

## Table
label<-c("HC SM+", "HC SM-", "LTBI SM+", "LTBI SM-", "TB SM+", "TB SM-")
total<-data.frame(cbind(labels, est, cil, ciu))

## Pvalues
theta<-matrix(c(fit_LTBI$drtmle$est, 
       fit_TB$drtmle$est), nrow=4, byrow=TRUE)
      
D<-cov(cbind(IC_LTBI, IC_TB))/941

A<-matrix(c( ###derivatives SM+ - SM-
    1,-1, 0, 0,
    0, 0, 1,-1),
    nrow=2, byrow = TRUE)

p1<- A %*% theta
p2<- solve(A %*% D %*% t(A))

teststat.total<-t(p1) %*% p2 %*% p1
pval<-pchisq(teststat.total, 2, lower.tail=FALSE)
kable(total, caption=paste("p=value=", pval, sep=""))
```

###HIV-
```{r}
N<-dim(IC_LTBI_HIVneg)[1]

## Estimates
lfit<-round(ci(fit_LTBI_HIVneg)[[1]], 3)
tfit<-round(ci(fit_TB_HIVneg)[[1]], 3)
HC<-c(1-(lfit[1,1]+tfit[1,1]),
      1-(lfit[2,1]+tfit[2,1]))
est<-100*c(HC, lfit[,1], tfit[,1])

## Confidence Intervals SM
#HC SM+
D<-cov(cbind(IC_LTBI_HIVneg[,1], IC_TB_HIVneg[,1]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.pos.up<-round(HC[1]+1.96*sqrt(var), 3)
hc.pos.low<-round(HC[1]-1.96*sqrt(var), 3)

#HC SM-
D<-cov(cbind(IC_LTBI_HIVneg[,2], IC_TB_HIVneg[,2]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.neg.up<-round(HC[2]+1.96*sqrt(var), 3)
hc.neg.low<-round(HC[2]-1.96*sqrt(var), 3)
cil<-100*c(hc.pos.low, hc.neg.low, lfit[,2], tfit[,2])
ciu<-100*c(hc.pos.up, hc.neg.up, lfit[,3], tfit[,3])

#Table
label<-c("HC SM+", "HC SM-", "LTBI SM+", "LTBI SM-", "TB SM+", "TB SM-")
Table.neg<-data.frame(cbind(label, est, cil, ciu))
Table.neg$HIV<-"HIV-"

## P values
theta<-matrix(c(fit_LTBI_HIVneg$drtmle$est, 
       fit_TB_HIVneg$drtmle$est), nrow=4, byrow=TRUE)
      
D<-cov(cbind(IC_LTBI_HIVneg, IC_TB_HIVneg))/573
    
A<-matrix(c( ###derivatives
    1,-1, 0, 0,
    0, 0, 1,-1),
    nrow=2, byrow = TRUE)

p1<- A %*% theta
p2<- solve(A %*% D %*% t(A))

teststat.HIVneg<-t(p1) %*% p2 %*% p1
pvalneg<-pchisq(teststat.HIVneg, 2, lower.tail=FALSE)
```

###HIV+
```{r}
N<-dim(IC_LTBI_HIVpos)[1]

## Estimates
lfit<-round(ci(fit_LTBI_HIVpos)[[1]], 3)
tfit<-round(ci(fit_TB_HIVpos)[[1]], 3)
HC<-c(1-(lfit[1,1]+tfit[1,1]),
      1-(lfit[2,1]+tfit[2,1]))
est<-100*c(HC, lfit[,1], tfit[,1])

## Confidence Intervals SM
#HC SM+
D<-cov(cbind(IC_LTBI_HIVpos[,1], IC_TB_HIVpos[,1]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.pos.up<-round(HC[1]+1.96*sqrt(var), 3)
hc.pos.low<-round(HC[1]-1.96*sqrt(var), 3)

#HC SM-
D<-cov(cbind(IC_LTBI_HIVpos[,2], IC_TB_HIVpos[,2]))/N
A<-matrix(c(-1,-1), ncol=1)
var<-t(A) %*% D %*% A
hc.neg.up<-round(HC[2]+1.96*sqrt(var), 3)
hc.neg.low<-round(HC[2]-1.96*sqrt(var), 3)
cil<-100*c(hc.pos.low, hc.neg.low, lfit[,2], tfit[,2])
ciu<-100*c(hc.pos.up, hc.neg.up, lfit[,3], tfit[,3])

#Table
label<-c("HC SM+", "HC SM-", "LTBI SM+", "LTBI SM-", "TB SM+", "TB SM-")
Table.pos<-data.frame(cbind(label, est, cil, ciu))
Table.pos$HIV<-"HIV+"


## P values
theta<-matrix(c(fit_LTBI_HIVpos$drtmle$est, 
       fit_TB_HIVpos$drtmle$est), nrow=4, byrow=TRUE)
      
D<-cov(cbind(IC_LTBI_HIVpos, IC_TB_HIVpos))/368

A<-matrix(c( ###derivatives
    1,-1, 0, 0,
    0, 0, 1,-1),
    nrow=2, byrow = TRUE)

p1<- A %*% theta
p2<- solve(A %*% D %*% t(A))

teststat.HIVpos<-t(p1) %*% p2 %*% p1
pvalpos<-pchisq(teststat.HIVpos, 2, lower.tail=FALSE)
```

###HIV- to HIV+
```{r}
theta<-matrix(c(fit_LTBI_HIVneg$drtmle$est, 
       fit_LTBI_HIVpos$drtmle$est,
       fit_TB_HIVneg$drtmle$est,
       fit_TB_HIVpos$drtmle$est), 
       nrow=8, byrow=TRUE)

neg<-cbind(IC_LTBI_HIVneg, rep(0, 573), rep(0, 573), IC_TB_HIVneg, rep(0, 573), rep(0, 573))
pos<-cbind(rep(0,368), rep(0,368), IC_LTBI_HIVpos, rep(0,368), rep(0,368), IC_TB_HIVpos)
inf<-rbind(neg, pos)
D<-cov(inf)/941

A<-matrix(c( ###derivatives
    1,-1,0, 0,  -1, 1, 0, 0,
    0,0, 1,-1,  0, 0, -1, 1),
    nrow=2, byrow=TRUE)

p1<- A %*% theta
p2<- solve(A %*% D %*% t(A))
teststat.hiv<-t(p1) %*% p2 %*% p1
pval<-pchisq(teststat.hiv, 2, lower.tail=FALSE)

complete<-rbind(Table.neg, Table.pos)
complete$TB<-tstrsplit(complete$label, " ")[[1]]
complete$SM<-tstrsplit(complete$label, " ")[[2]]
complete$CI<-paste0("(", complete$cil, " - ", complete$ciu, ")")
complete$pretty<-paste(complete$est, "%", "\n", complete$CI,sep="")
complete$disease<-paste(complete$HIV, complete$SM, sep=" ")
graph<-complete

##To make it pretty as a table
presentable<-pivot_wider(complete, values_from = pretty, names_from=disease, id_cols = TB)
rownames(presentable)<-presentable$TB
presentable<-dplyr::select(presentable, -TB)
```

Literally just to have in case I need to do error bars again
```{r}
graph$est<-as.numeric(as.character(graph$est))
graph$cil<-as.numeric(as.character(graph$cil))
graph$ciu<-as.numeric(as.character(graph$ciu))
graph$lower<-NA
graph$upper<-NA
for(i in 1:nrow(graph)){
    if (graph$TB[i]=="TB") {
        graph$lower[i]<-graph$cil[i]
        graph$upper[i]<-graph$ciu[i]}
}
##LOWER
#HIV-
graph$lower[graph$TB=="HC" & graph$disease=="HIV- SM-"]<-
    graph$cil[graph$TB=="HC" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]

graph$lower[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]<-
    graph$cil[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM-"]

graph$lower[graph$TB=="HC" & graph$disease=="HIV- SM+"]<-
    graph$cil[graph$TB=="HC" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]

graph$lower[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]<-
    graph$cil[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM+"]

#HIV+
graph$lower[graph$TB=="HC" & graph$disease=="HIV+ SM-"]<-
    graph$cil[graph$TB=="HC" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]

graph$lower[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]<-
    graph$cil[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM-"]

graph$lower[graph$TB=="HC" & graph$disease=="HIV+ SM+"]<-
    graph$cil[graph$TB=="HC" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]

graph$lower[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]<-
    graph$cil[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM+"]

##UPPER
#HIV-
graph$upper[graph$TB=="HC" & graph$disease=="HIV- SM-"]<-
    graph$ciu[graph$TB=="HC" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]

graph$upper[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]<-
    graph$ciu[graph$TB=="LTBI" & graph$disease=="HIV- SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM-"]

graph$upper[graph$TB=="HC" & graph$disease=="HIV- SM+"]<-
    graph$ciu[graph$TB=="HC" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]

graph$upper[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]<-
    graph$ciu[graph$TB=="LTBI" & graph$disease=="HIV- SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV- SM+"]

#HIV+
graph$upper[graph$TB=="HC" & graph$disease=="HIV+ SM-"]<-
    graph$ciu[graph$TB=="HC" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]

graph$upper[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]<-
    graph$ciu[graph$TB=="LTBI" & graph$disease=="HIV+ SM-"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM-"]

graph$upper[graph$TB=="HC" & graph$disease=="HIV+ SM+"]<-
    graph$ciu[graph$TB=="HC" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]

graph$upper[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]<-
    graph$ciu[graph$TB=="LTBI" & graph$disease=="HIV+ SM+"]+
    graph$est[graph$TB=="TB" & graph$disease=="HIV+ SM+"]
```
 
```{r, fig.width=9, fig.height=7}
source("/Users/tarynam/Desktop/Miscellaneous-Scripts/plot_functions.R")

a<-ggplot(graph, aes(x=SM, y=est, fill=label))+
  geom_col(position = 'stack')+geom_bar(stat="identity", colour="black")+
  scale_fill_manual(values=all.cols)+
  geom_text(aes(label = pretty, color=SM), 
              position = position_stack(vjust = .5), size=6)+
  scale_color_manual(values=c("black", "white"), guide=FALSE)+
  facet_grid(~HIV)+
  theme_classic()+
  theme(text = element_text(size=24), plot.title = element_text(size=26)) +
  theme(legend.position = "bottom", legend.title = element_blank())+
  labs(x="", y="Probability")+
  scale_y_continuous(breaks=c(0,25,50,75,100), limits=c(0,120))
a
```
  
### Comparing SM- to SM+ in HIV-: `r round(pvalneg,4)`  
### Comparing SM- to SM+ in HIV+: `r round(pvalpos, 4)`  
### Comparing HIV- to HIV+: `r round(pval,4)`  


```{r}
write.csv(presentable, "/Users/tarynam/Desktop/manuscript-drtmle/drtmle_results.csv")
cowplot::save_plot("/Users/tarynam/Desktop/manuscript-drtmle/fig2.png", a, base_height = 8, base_width = 10)
```


## Cross-Validation of Super Learner
### Propensity Score
```{r, eval=FALSE}
cv.g<-summary(cv_g)$Table
cv.g<-arrange(cv.g, Ave)
cv.g$Algorithm<-gsub("_All|SL.", "", cv.g$Algorithm)
ggplot(cv.g, aes(x=Ave, y=reorder(Algorithm, -Ave)))+
    geom_point(size=3)+
    geom_segment(aes(x=Min, xend=Max, y=Algorithm, yend=Algorithm), size=0.5)+
    theme_bw()+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(text = element_text(size=16))+
    labs(x="10-fold CV Risk Estimate",
         y="Algorithm",
         title="Propensity Score")+
    coord_cartesian(xlim=c(0,1.8))
```

### LTBI
```{r, eval=FALSE}
cv.l<-summary(cv_ltbi)$Table
cv.l<-arrange(cv.l, Ave)
cv.l$Algorithm<-gsub("_All|SL.", "", cv.l$Algorithm)
ggplot(cv.l, aes(x=Ave, y=reorder(Algorithm, -Ave)))+
    geom_point(size=3)+
    geom_segment(aes(x=Min, xend=Max, y=Algorithm, yend=Algorithm), size=0.5)+
    theme_bw()+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(text = element_text(size=16))+
    labs(x="10-fold CV Risk Estimate",
         y="Algorithm",
         title="LTBI Outcome Regression")+
    coord_cartesian(xlim=c(0,1.8))
```

### TB
```{r, eval=FALSE}
cv.t<-summary(cv_tb)$Table
cv.t<-arrange(cv.t, Ave)
cv.t$Algorithm<-gsub("_All|SL.", "", cv.t$Algorithm)
cv.t$Ave[cv.t$Algorithm=="rpartPrune"]<-NA
cv.t$Max[cv.t$Algorithm=="rpartPrune"]<-NA
ggplot(cv.t, aes(x=Ave, y=reorder(Algorithm, -Ave)))+
    geom_point(size=3)+
    geom_segment(aes(x=Min, xend=Max, y=Algorithm, yend=Algorithm), size=0.5)+
    theme_bw()+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(text = element_text(size=16))+
    labs(x="10-fold CV Risk Estimate",
         y="Algorithm",
         title="TB Outcome Regression")
```

